# frozen_string_literal: true

require 'simplecov'
SimpleCov.start 'rails' do
  add_filter '/spec/'
  add_filter '/config/'
  add_filter '/vendor/'

  add_group 'Controllers', 'app/controllers'
  add_group 'Models', 'app/models'
  add_group 'Mailers', 'app/mailers'
  add_group 'Jobs', 'app/jobs'
end

# This file was generated by the `rails generate rspec:install` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# See https://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration

# frozen_string_literal: true

require 'bundler/setup'
require 'resourcespace'
require 'webmock/rspec'
require 'vcr'

# Configure WebMock
WebMock.disable_net_connect!(allow_localhost: true)

# Configure VCR for recording HTTP interactions
VCR.configure do |config|
  config.cassette_library_dir = 'spec/fixtures/vcr_cassettes'
  config.hook_into :webmock
  config.configure_rspec_metadata!
  config.default_cassette_options = {
    record: :new_episodes,
    allow_playback_repeats: true,
    match_requests_on: %i[method uri body]
  }

  # Filter out sensitive data
  config.filter_sensitive_data('<PRIVATE_KEY>') do |interaction|
    interaction.request.body.match(/sign=([^&]+)/)[1] if interaction.request.body.include?('sign=')
  end
  config.filter_sensitive_data('<USER>') do |interaction|
    interaction.request.body.match(/user=([^&]+)/)[1] if interaction.request.body.include?('user=')
  end
end

RSpec.configure do |config|
  # Enable flags like --only-failures and --next-failure
  config.example_status_persistence_file_path = '.rspec_status'

  # Disable RSpec exposing methods globally on Module and main
  config.disable_monkey_patching!

  config.expect_with :rspec do |c|
    c.syntax = :expect
  end

  # Reset ResourceSpace configuration before each test
  config.before(:each) do
    ResourceSpace.reset_config!
  end

  # Shared test configuration
  config.before(:suite) do
    # Any global setup
  end

  config.after(:suite) do
    # Any global cleanup
  end
end

# Test helper methods
module TestHelpers
  def valid_config
    {
      url: 'https://demo.resourcespace.com/api/',
      user: 'test_user',
      private_key: 'test_private_key_12345'
    }
  end

  def create_test_client(**options)
    config = valid_config.merge(options)
    ResourceSpace::Client.new(**config)
  end

  def stub_api_request(method, function, params = {}, response = {})
    request_params = {
      user: 'test_user',
      function: function
    }.merge(params)

    # Generate expected signature for stubbing (matching client logic)
    query_string = URI.encode_www_form(request_params.reject { |_k, v| v.is_a?(String) && v.start_with?('data:') })
    signature = Digest::SHA256.hexdigest("test_private_key_12345#{query_string}")

    # Add signature and authmode after signature generation (like the client does)
    request_params[:sign] = signature
    request_params[:authmode] = 'userkey'

    if method == :get
      stub_request(:get, 'https://demo.resourcespace.com/api/')
        .with(query: request_params)
        .to_return(
          status: 200,
          body: response.to_json,
          headers: { 'Content-Type' => 'application/json' }
        )
    else
      stub_request(:post, 'https://demo.resourcespace.com/api/')
        .with(body: URI.encode_www_form(request_params))
        .to_return(
          status: 200,
          body: response.to_json,
          headers: { 'Content-Type' => 'application/json' }
        )
    end
  end

  def stub_error_response(method, function, status_code, error_message = nil, params = {})
    request_params = {
      user: 'test_user',
      function: function
    }.merge(params)

    # Generate signature matching client logic
    query_string = URI.encode_www_form(request_params)
    signature = Digest::SHA256.hexdigest("test_private_key_12345#{query_string}")

    # Add signature and authmode after signature generation
    request_params[:sign] = signature
    request_params[:authmode] = 'userkey'

    error_body = error_message ? { error: error_message }.to_json : ''

    if method == :get
      stub_request(:get, 'https://demo.resourcespace.com/api/')
        .with(query: request_params)
        .to_return(status: status_code, body: error_body)
    else
      stub_request(:post, 'https://demo.resourcespace.com/api/')
        .with(body: URI.encode_www_form(request_params))
        .to_return(status: status_code, body: error_body)
    end
  end
end

RSpec.configure do |config|
  config.include TestHelpers
end
